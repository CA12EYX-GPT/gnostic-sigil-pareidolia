<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gnostic Sigil Pareidolia — Waterfall</title>
<meta name="color-scheme" content="dark">
<style>
  :root {
    --bg: #0b0b0b;
    --fg: #e6e6e6;
    --muted: #9aa0a6;
    --glow: #00e0d1;      /* teal for words & static sigils */
    --leader: #ff4343;    /* red for moving leader sigils */
  }
  html, body { height: 100%; }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font: 16px/1.25 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    letter-spacing: 0.02em;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    overflow: hidden;
  }
  .bar {
    position: fixed; inset: 0 0 auto 0; height: 44px;
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 12px;
    background: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
    backdrop-filter: blur(2px);
    pointer-events: none;
  }
  .brand { opacity: .75; font-weight: 600; }
  .mode {
    pointer-events: auto;
    font-size: 12px;
    color: var(--muted);
    padding: 4px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.08);
    background: rgba(255,255,255,.03);
    user-select: none;
  }
  .button {
    pointer-events: auto;
    font-size: 12px;
    color: var(--fg);
    padding: 4px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    cursor: pointer;
    margin-left: 8px;
  }
  .button:focus-visible { outline: 2px solid var(--glow); outline-offset: 2px; }
  .hint { opacity: .6; font-size: 12px; margin-left: 8px; }

  #app { position: fixed; inset: 0; display: grid; place-items: center; }
  #grid {
    width: 92vw; height: 82vh;            /* tighter overall size */
    display: grid;
    grid-template-rows: repeat(24, 1fr);
    gap: 1px;                              /* tighter gaps */
    filter: drop-shadow(0 1px 0 rgba(255,255,255,.04));
  }
  .row { display: grid; grid-template-columns: repeat(64, 1fr); gap: 1px; }

  .cell {
    display: flex; align-items: center; justify-content: center;
    min-width: 0;
    opacity: .95;
    transition: opacity .15s linear, transform .15s linear;
    will-change: contents, opacity;
  }

  .word { color: var(--glow); text-shadow: 0 0 10px var(--glow); font-weight: 600; }
  .leader {
    color: var(--leader);
    text-shadow: 0 0 10px var(--leader), 0 0 18px rgba(255,67,67,.45);
    font-weight: 700;
    transform: translateZ(0);
  }
  .sigil-static {
    color: var(--glow);
    text-shadow: 0 0 8px var(--glow);
    font-weight: 600;
  }

  /* Subtle shimmer */
  @keyframes shimmer { 0% { opacity: .94; } 50% { opacity: .98; } 100% { opacity: .94; } }
  #grid { animation: shimmer 6s ease-in-out infinite; }

  /* Ritual mode intensifies the vibe slightly */
  .ritual .cell { opacity: .97; }
  .ritual #grid { animation-duration: 4.5s; }

  /* --- Mobile polish (portrait phones) --- */
  @media (max-width: 768px) and (orientation: portrait) {
    .bar { height: 40px; padding: 0 10px; }
    .hint { display: none; }
    .button { padding: 4px 8px; font-size: 11px; }
    #grid {
      aspect-ratio: 64 / 24;
      width: min(98vw, calc(100vh - 52px));
      height: auto;
      gap: 0.75px;
    }
    .row { gap: 0.75px; }
    body { font-size: clamp(12px, 3.6vw, 14px); }
  }
  @media (max-width: 380px) and (orientation: portrait) {
    #grid { gap: 0.5px; }
    .row  { gap: 0.5px; }
    body  { font-size: clamp(11px, 3.8vw, 13px); }
  }
  @media (max-height: 520px) and (orientation: landscape) {
    .bar { height: 36px; }
    #grid {
      aspect-ratio: 64 / 24;
      height: calc(100vh - 44px);
      width: auto;
      gap: 0.75px;
    }
    .row { gap: 0.75px; }
  }
</style>
</head>
<body>
<div class="bar" role="region" aria-label="Controls">
  <div class="brand">Gnostic Sigil Pareidolia</div>
  <div>
    <span id="mode" class="mode" aria-live="polite">Mode: Normal</span>
    <button id="toggle-ritual" class="button" type="button" aria-pressed="false">Toggle Ritual (R)</button>
    <span class="hint">Press <kbd>R</kbd> or click</span>
  </div>
</div>
<div id="app" aria-live="polite" aria-busy="false">
  <div id="grid"></div>
</div>

<script>
(function(){
  const COLS = 64, ROWS = 24;
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const leaderSigils = ["◉","∆","⟁","✧","◬","◆"];

  /* Word packs (curated) */
  const PACKS = {
    gnostic: ["AEON","PNEU","LOGOS","NOUS","SOPHIA","PLEROMA","ARCHON","DAEMON","ABRAX","OGDOAD","SETH","YALT","BARB","HYMN","RITE","MYTH","SIGIL","OROB","EIDOL","GNOSIS","APOPH"],
    spiritual: ["AURA","OMEN","GRACE","ANGEL","LOTUS","PRANA","MANA","NAMAS","ALIGN","LIGHT","GUIDE","HEART","SOUL","INNER","CHANT","BREATHE","FAITH","HOPE","PEACE","BLESS"],
    positive: ["KIND","BRAVE","TRUE","LUCK","SMILE","SHINE","JOY","CALM","EASE","GOOD","RISE","GLOW","LOVE","HEAL","TRUST","CLEAR","AIM","FLOW","BEST","WIN"],
    neutral:  ["THE","AND","YOU","SUN","SEA","ARC","ORB","KEY","EYE","ART","STAR","PATH","SIGN","SONG"]
  };

  /* Pre-index by length for O(1) selection */
  const PACKS_BY_LEN = {};
  for (const [pack, list] of Object.entries(PACKS)) {
    for (const w of list) {
      const L = w.length;
      (PACKS_BY_LEN[pack] ??= {})[L] ??= [];
      PACKS_BY_LEN[pack][L].push(w);
    }
  }

  function pickPack(ritual){
    const weights = ritual
      ? [["gnostic",0.55],["spiritual",0.25],["positive",0.15],["neutral",0.05]]
      : [["gnostic",0.25],["spiritual",0.30],["positive",0.30],["neutral",0.15]];
    const r = Math.random(); let acc=0;
    for (const [name,w] of weights){ acc+=w; if(r<acc) return name; }
    return "neutral";
  }
  function pickWordByLength(desiredLen, ritual){
    const table = PACKS_BY_LEN[pickPack(ritual)];
    if (!table) return null;
    const lens = [desiredLen, desiredLen-1, desiredLen+1, desiredLen-2, desiredLen+2];
    for (const L of lens){ const arr = table[L]; if (arr?.length) return arr[(Math.random()*arr.length)|0]; }
    const flat = Object.values(table).flat();
    return flat.length ? flat[(Math.random()*flat.length)|0] : null;
  }

  const gridEl = document.getElementById('grid');
  const modeEl = document.getElementById('mode');
  const toggleBtn = document.getElementById('toggle-ritual');
  if(!gridEl) return;

  /* Build grid once */
  const rows = [];
  for(let r=0;r<ROWS;r++){
    const row = document.createElement('div');
    row.className = 'row';
    const cells = [];
    for(let c=0;c<COLS;c++){
      const span = document.createElement('span');
      span.className = 'cell';
      span.textContent = letters[(Math.random()*letters.length)|0];
      row.appendChild(span);
      cells.push(span);
    }
    gridEl.appendChild(row);
    rows.push(cells);
  }

  /* Glow-overlap guards */
  let glowSeq = 0;                          // unique id per glow
  const rowGlowBusy = Array(ROWS).fill(false);
  function spanIsFree(r, start, len){
    for (let i=0;i<len;i++){
      const cell = rows[r]?.[start+i];
      if (!cell) return false;
      if (cell.classList.contains('word') || cell.classList.contains('leader')) return false;
    }
    return true;
  }

  /* Ritual toggle */
  let ritual = false;
  function setMode(isRitual){
    ritual = !!isRitual;
    document.body.classList.toggle('ritual', ritual);
    modeEl.textContent = ritual ? "Mode: Ritual" : "Mode: Normal";
    toggleBtn.setAttribute('aria-pressed', ritual ? 'true' : 'false');
  }
  toggleBtn?.addEventListener('click', () => setMode(!ritual));
  function isTypingInField(t){ return t && (t.isContentEditable || ['INPUT','TEXTAREA','SELECT'].includes(t.tagName)); }
  document.addEventListener('keydown', (e)=>{ if(isTypingInField(e.target)) return; if((e.key||'').toLowerCase()==='r'){ e.preventDefault(); setMode(!ritual); }});

  /* Word glow (2× duration) with no-overlap + IDs */
  function maybeGlow(r, c){
    let len = 3;
    if (Math.random() < (ritual ? 0.45 : 0.25)) len++;
    if (Math.random() < (ritual ? 0.20 : 0.10)) len++;
    const start = c - (len - 1);
    if (start < 0) return;
    if (rowGlowBusy[r]) return;
    if (!spanIsFree(r, start, len)) return;

    const word = pickWordByLength(len, ritual);
    if (!word) return;

    const id = (++glowSeq) + "";
    const txt = word.slice(-len);
    rowGlowBusy[r] = true;
    const dur = ritual ? 2200 : 1600;

    for (let i=0;i<txt.length;i++){
      const cell = rows[r][start + i];
      cell.textContent = txt[i];
      cell.classList.remove('leader','sigil-static');
      cell.dataset.wordId = id;
      cell.classList.add('word');
    }
    setTimeout(()=>{
      for (let i=0;i<txt.length;i++){
        const cell = rows[r][start + i];
        if (cell && cell.dataset.wordId === id){
          cell.classList.remove('word');
          delete cell.dataset.wordId;
        }
      }
      rowGlowBusy[r] = false;
    }, dur);
  }

  /* Change a cell: letters OR rare static teal sigil */
  function changeCell(r, c, allowGlow = true){
    const cell = rows[r]?.[c];
    if(!cell) return;

    // Clear any previous roles
    cell.classList.remove('leader','sigil-static','word');
    delete cell.dataset.wordId;

    // Rare static teal sigil for ambience
    const staticSigilChance = ritual ? 0.03 : 0.015;
    if (Math.random() < staticSigilChance){
      const sig = leaderSigils[(Math.random()*leaderSigils.length)|0];
      cell.textContent = sig;
      cell.classList.add('sigil-static');
      return;
    }

    // Normal letter change
    cell.textContent = letters[(Math.random()*letters.length)|0];

    // Micro flicker
    if(Math.random() < (ritual ? 0.04 : 0.025)){
      cell.style.opacity = "0.7";
      setTimeout(()=>{ cell.style.opacity = "0.95"; }, 160);
    }

    // Maybe glow a word
    const wordChance = ritual ? 0.14 : 0.10;
    if(allowGlow && Math.random() < wordChance) maybeGlow(r, c);
  }

  /* Leader helpers */
  const leaderChars = Array.from({length: ROWS}, (_,r)=> leaderSigils[r % leaderSigils.length]);
  function setLeader(r, c){
    const cell = rows[r]?.[c];
    if(!cell) return;
    cell.textContent = leaderChars[r];
    cell.classList.add('leader');
  }
  function clearAllLeaders(){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) rows[r][c].classList.remove('leader');
  }

  /* Geometry: rings */
  const cx = (COLS-1)/2, cy = (ROWS-1)/2;
  const circleBuckets = new Map(); let maxCircle = 0;
  const squareBuckets = new Map(); let maxSquare = 0;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const kC = Math.round(Math.hypot(c - cx, r - cy));
      maxCircle = Math.max(maxCircle, kC);
      (circleBuckets.get(kC) || circleBuckets.set(kC,[]).get(kC)).push([r,c]);

      const kS = Math.max(Math.abs(c - cx), Math.abs(r - cy));
      maxSquare = Math.max(maxSquare, kS);
      (squareBuckets.get(kS) || squareBuckets.set(kS,[]).get(kS)).push([r,c]);
    }
  }

  /* Patterns */
  const PATTERNS = ["line","radial","multilines","square","zigzag","line"];
  let phaseIndex = 0, tickInPhase = 0;
  let lineHeads = Array.from({length: ROWS}, ()=> 0);
  let multilinesStarts = [];

  function initPhase(name){
    clearAllLeaders();
    tickInPhase = 0;
    if(name === "line"){
      lineHeads = Array.from({length: ROWS}, ()=> 0);
      for(let r=0;r<ROWS;r++) setLeader(r, 0);
    } else if(name === "multilines"){
      multilinesStarts = Array.from({length: ROWS}, ()=>{
        const count = 2 + ((Math.random()*3)|0); // 2–4 per row
        const picks = new Set();
        while(picks.size < count) picks.add((Math.random()*COLS)|0);
        return Array.from(picks);
      });
    }
  }

  function phaseDuration(name){
    switch(name){
      case "line":        return COLS;
      case "radial":      return maxCircle + 1;
      case "square":      return maxSquare + 1;
      case "multilines":  return COLS;
      case "zigzag":      return COLS * 2;
      default:            return COLS;
    }
  }

  function stepPhase(name){
    // Clear previous tick’s leaders so heads don’t leave red trails
    clearAllLeaders();

    if(name === "line"){
      for(let r=0;r<ROWS;r++){
        const prev = lineHeads[r], next = (prev + 1) % COLS;
        changeCell(r, prev, true);
        setLeader(r, next);
        lineHeads[r] = next;
      }

    } else if(name === "radial"){
      const ring = circleBuckets.get(tickInPhase);
      if(ring){
        for(const [r,c] of ring) changeCell(r, c, true);
        for(const [r,c] of ring) setLeader(r, c); // show ring heads
      }

    } else if(name === "square"){
      const ring = squareBuckets.get(tickInPhase);
      if(ring){
        for(const [r,c] of ring) changeCell(r, c, true);
        for(const [r,c] of ring) setLeader(r, c);
      }

    } else if(name === "multilines"){
      for(let r=0;r<ROWS;r++){
        const starts = multilinesStarts[r];
        for(const s of starts){
          const col = (s + tickInPhase) % COLS;
          changeCell(r, col, true);
          setLeader(r, col);
        }
      }

    } else if(name === "zigzag"){
      for(let r=0;r<ROWS;r++){
        const col = r % 2 === 0 ? (tickInPhase % COLS) : (COLS - 1 - (tickInPhase % COLS));
        changeCell(r, col, true);
        setLeader(r, col);
      }
    }

    tickInPhase++;
    if(tickInPhase >= phaseDuration(name)){
      phaseIndex = (phaseIndex + 1) % PATTERNS.length;
      initPhase(PATTERNS[phaseIndex]);
    }
  }

  /* Start */
  initPhase(PATTERNS[phaseIndex]);
  let rafId = 0;
  function loop(){ stepPhase(PATTERNS[phaseIndex]); rafId = requestAnimationFrame(loop); }
  requestAnimationFrame(()=>{ loop(); });

  /* Power-save when hidden */
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){ cancelAnimationFrame(rafId); }
    else { rafId = requestAnimationFrame(loop); }
  });
})();
</script>
</body>
</html>
