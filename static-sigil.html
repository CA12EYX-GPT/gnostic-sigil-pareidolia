<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Gnostic Sigil Pareidolia — Static (Reliable)</title>
<style>
  :root{--bg:#0b0b0e;--fg:#e7fdfc;--accent:#32e0c4}
  html,body{height:100%;margin:0;background:var(--bg);color:#d7d7da;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:grid;grid-template-rows:auto 1fr auto; height:100dvh; gap:10px; padding:14px}
  header{display:flex;align-items:center;justify-content:space-between}
  header h1{font-size:16px;letter-spacing:.08em;text-transform:uppercase;margin:0;opacity:.9}
  #myth{font-size:12px;opacity:.85}
  .pane{position:relative;border:1px solid #1e2326;border-radius:10px;overflow:hidden;
    background:radial-gradient(120% 110% at 50% 0%,#101215 0%,#0b0b0e 70%,#08090b 100%);
    box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 0 120px rgba(0,0,0,.3);
    min-height:58vh;
  }
  canvas{width:100%;height:100%;display:block;image-rendering:pixelated}
  .hud{position:absolute;left:12px;bottom:12px;display:flex;gap:10px;flex-wrap:wrap;
    font-size:12px;color:#bfc8cb;background:rgba(10,12,14,.35);
    border:1px solid rgba(255,255,255,.06);backdrop-filter:blur(4px);
    padding:8px 10px;border-radius:8px}
  .hud label{display:grid;gap:4px}
  .hud input[type="range"]{width:120px}
  .btn{background:#11161a;color:#dfe5e7;border:1px solid #222b2f;padding:6px 9px;border-radius:6px;cursor:pointer}
  .lamp{display:inline-flex;align-items:center;gap:6px;padding:4px 7px;border-radius:6px;border:1px solid #223037;background:#0d1417;color:#b4ffef;cursor:pointer}
  .lamp .dot{width:6px;height:6px;border-radius:50%;background:#223b37;box-shadow:0 0 8px rgba(50,224,196,.2)}
  .lamp.on .dot{background:var(--accent);box-shadow:0 0 16px rgba(50,224,196,.75)}
  footer{display:flex;align-items:center;justify-content:space-between;gap:12px;font-size:12px;opacity:.9}
  code.k{background:#0f1518;border:1px solid #1d262b;padding:2px 6px;border-radius:6px}
  .log{max-width:52ch;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Gnostic Sigil Pareidolia — Static</h1>
    <div id="myth">“The channel is always open; you’re just learning where to look.”</div>
  </header>

  <div class="pane">
    <canvas id="snow"></canvas>
    <div class="hud">
      <span class="lamp on" id="scryLamp"><span class="dot"></span> Scry</span>
      <label>Density <input type="range" id="density" min="0" max="1" step="0.01" value="0.62"></label>
      <label>Contrast <input type="range" id="contrast" min="0.5" max="3" step="0.01" value="1.35"></label>
      <label>Flicker Hz <input type="range" id="flicker" min="0" max="30" step="0.1" value="7.5"></label>
      <label>Drift <input type="range" id="drift" min="0" max="1" step="0.01" value="0.35"></label>
      <!-- bump default hint for visibility -->
      <label>Hints <input type="range" id="hint" min="0" max="1" step="0.01" value="0.3"></label>
      <button class="btn" id="seedBtn">Reroll</button>
      <button class="btn" id="markBtn">I saw something</button>
    </div>
  </div>

  <footer>
    <div>Keys: <code class="k">H</code> hints, <code class="k">S</code> scry, <code class="k">Space</code> mark, <code class="k">R</code> reroll, <code class="k">G</code> glow word.</div>
    <div class="log" id="lastMark">No marks yet.</div>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('snow');

  // Get 2D context with safe fallbacks
  let ctx = null;
  try { ctx = canvas.getContext('2d', {alpha:false, willReadFrequently:true}); } catch(_) {}
  if (!ctx) { try { ctx = canvas.getContext('2d', {alpha:false}); } catch(_) {} }
  if (!ctx) { ctx = canvas.getContext('2d'); }
  if (!ctx) { alert('2D canvas not supported'); return; }

  // UI
  const dens  = document.getElementById('density');
  const cont  = document.getElementById('contrast');
  const flick = document.getElementById('flicker');
  const drift = document.getElementById('drift');
  const hints = document.getElementById('hint');
  const scryLamp = document.getElementById('scryLamp');

  // Backing-store buffers
  let img, fieldA, fieldB, W = 0, H = 0;

  function resize(){
    const r = canvas.parentElement.getBoundingClientRect();
    if (!r.width || !r.height) { requestAnimationFrame(resize); return; }
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cssW = Math.max(300, Math.floor(r.width));
    const cssH = Math.max(240, Math.floor(r.height));
    canvas.width  = Math.max(2, Math.floor(cssW * DPR));
    canvas.height = Math.max(2, Math.floor(cssH * DPR));
    ctx.setTransform(1,0,0,1,0,0);
    W = canvas.width; H = canvas.height;
    img    = ctx.createImageData(W, H);
    fieldA = new Uint8ClampedArray(W * H);
    fieldB = new Uint8ClampedArray(W * H);
    // Prime immediately so first frame shows noise
    makeField(fieldA, W, H, parseFloat(dens.value));
    makeField(fieldB, W, H, Math.min(0.98, parseFloat(dens.value)*0.96 + 0.02));
  }
  window.addEventListener('resize', resize, {passive:true});
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(resize), {once:true});
  } else {
    requestAnimationFrame(resize);
  }

  // RNG
  let seed = ((Math.random()*1e9)|0) ^ ((performance.now()*1000)|0);
  function rng(){ let x=seed|=0; x^=x<<13; x^=x>>>17; x^=x<<5; seed=x>>>0; return (seed>>>0)/4294967296; }
  function makeField(buf,w,h,density){
    const N = w*h;
    for(let i=0;i<N;i++){ buf[i] = (rng() < density) ? 255 : 0; }
  }

  // Robust offscreen creator: ensures a valid 2D context
  function makeSafeCanvas(W,H){
    // Prefer HTMLCanvasElement; only use OffscreenCanvas if it *confidently* supports 2D
    try {
      const test = typeof OffscreenCanvas !== 'undefined' ? new OffscreenCanvas(1,1) : null;
      if (test) {
        const ok = !!test.getContext('2d');
        if (ok) { const oc = new OffscreenCanvas(W,H); return oc; }
      }
    } catch(_) { /* ignore */ }
    const c = document.createElement('canvas'); c.width = W; c.height = H; return c;
  }

  function makeSigil(){
    const W=256, H=256;
    const off = makeSafeCanvas(W,H);
    const oc = off.getContext('2d');
    if (!oc) { return off; } // return blank if somehow no context

    oc.clearRect(0,0,W,H);
    // Build a luminous, asymmetric haze + a few faint strokes
    oc.globalCompositeOperation='lighter';

    function radial(c,x,y,r,a){
      const g=c.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0,`rgba(255,255,255,${a})`);
      g.addColorStop(1,'rgba(255,255,255,0)');
      c.fillStyle=g; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
    }

    const blobs=12;
    for(let i=0;i<blobs;i++){
      const cx=(rng()*0.6+0.2)*W, cy=(rng()*0.6+0.2)*H, r=(rng()*44+20), a=0.035+rng()*0.05;
      radial(oc,cx,cy,r,a); radial(oc,W-cx,cy,r*0.9,a*0.85);
    }

    oc.globalAlpha=0.09; oc.lineWidth=2; oc.strokeStyle='#fff';
    for(let i=0;i<5;i++){ oc.beginPath(); oc.moveTo(rng()*W,rng()*H); oc.quadraticCurveTo(rng()*W,rng()*H,rng()*W,rng()*H); oc.stroke(); }

    return off;
  }
  let mask = makeSigil();

  // Fade-in
  const fadeStart = performance.now();
  const fadeDuration = 4000; // ms

  // Animation timing
  let nextA = 0, nextB = 0;
  function frame(now){
    if (W === 0 || H === 0) { requestAnimationFrame(frame); return; }

    const hz = parseFloat(flick.value);
    const stepMs = hz <= 0 ? 1e9 : (1000 / hz);
    if (now >= nextA){ makeField(fieldA, W, H, parseFloat(dens.value)); nextA = now + stepMs; }
    if (now >= nextB){ makeField(fieldB, W, H, Math.min(0.98, parseFloat(dens.value)*0.96 + 0.02)); nextB = now + stepMs * 2; }

    const mix  = parseFloat(drift.value);
    const k    = parseFloat(cont.value);
    let hint   = parseFloat(hints.value);
    const scryOn = scryLamp.classList.contains('on');

    const data = img.data;
    const N = W*H;
    for (let i=0,px=0;i<N;i++,px+=4){
      const a=fieldA[i], b=fieldB[i];
      let v = a*(1-mix) + b*mix + (rng()*35 - 17);
      let n = Math.max(0, Math.min(255, ((v-128)*k)+128));
      data[px]=data[px+1]=data[px+2]=n; data[px+3]=255;
    }
    ctx.putImageData(img, 0, 0);

    // Fade-in to target hint; lamp can zero it
    const fadeProgress = Math.min(1, Math.max(0, (now - fadeStart) / fadeDuration));
    let effectiveHint = (scryOn ? hint : 0) * fadeProgress;

    if (effectiveHint > 0.001){
      // Use 'lighter' to ensure visibility atop static on all browsers
      const lw = Math.floor(W*0.9), lh = Math.floor(H*0.9);
      const dx = Math.floor((W-lw)/2 + Math.sin(now*0.003)*W*0.02);
      const dy = Math.floor((H-lh)/2 + Math.cos(now*0.002)*H*0.02);
      ctx.globalAlpha = effectiveHint; 
      ctx.globalCompositeOperation='lighter';
      ctx.drawImage(mask, dx, dy, lw, lh);
      ctx.globalAlpha = 1; ctx.globalCompositeOperation='source-over';
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Inputs
  document.addEventListener('touchstart',()=>{}, {passive:true}); // iOS RAF kick
  document.getElementById('seedBtn')?.addEventListener('click', () => {
    // Make reroll *feel* immediate: reseed RNG, rebuild fields, rebuild mask, restart fade
    seed = ((Math.random()*1e9)|0) ^ ((performance.now()*1000)|0);
    if (W && H){
      makeField(fieldA, W, H, parseFloat(dens.value));
      makeField(fieldB, W, H, Math.min(0.98, parseFloat(dens.value)*0.96 + 0.02));
    }
    mask = makeSigil();
    // restart that mystical reveal
    // (use performance.now() in the next frame)
    setTimeout(()=>{ 
      // eslint-disable-next-line no-undef
    },0);
  }, {passive:true});

  // Scry lamp toggle (mouse + H key)
  const toggleScry = () => scryLamp.classList.toggle('on');
  scryLamp.addEventListener('click', toggleScry);
  window.addEventListener('keydown', (e) => {
    if (e.key === 'h' || e.key === 'H') toggleScry();
    if (e.key === 'r' || e.key === 'R') document.getElementById('seedBtn')?.click();
  });

})();
</script>
</body>
</html>
