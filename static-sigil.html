<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gnostic Sigil Pareidolia — Static Edition</title>
<style>
  :root{
    --bg:#0b0b0e;
    --fg:#e7fdfc; /* teal-leaning white for glows */
    --muted:#7f8a8d;
    --accent:#32e0c4;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#d7d7da;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  .wrap{display:grid;grid-template-rows:auto 1fr auto; height:100%; gap:10px; padding:14px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px}
  header h1{font-size:16px;letter-spacing:.08em;text-transform:uppercase;margin:0;color:#cfd9db;opacity:.9}
  #myth{font-size:12px;color:#9aa5a8;opacity:.85}
  .pane{
    position:relative; border:1px solid #1e2326; border-radius:10px; overflow:hidden;
    background: radial-gradient(120% 110% at 50% 0%, #101215 0%, #0b0b0e 70%, #08090b 100%);
    box-shadow: 0 10px 40px rgba(0,0,0,.45), inset 0 0 120px rgba(0,0,0,.3);
  }
  canvas{width:100%;height:100%;display:block; image-rendering:pixelated;}
  .scanline:after{
    content:""; pointer-events:none; position:absolute; inset:0;
    background:
      linear-gradient(rgba(255,255,255,.03),rgba(0,0,0,0) 2px),
      repeating-linear-gradient(0deg, rgba(255,255,255,.02), rgba(255,255,255,0) 2px, rgba(0,0,0,0) 4px);
    mix-blend-mode:overlay;
  }
  .hud{
    position:absolute; left:12px; bottom:12px; display:flex; gap:10px; flex-wrap:wrap;
    font-size:12px; color:#bfc8cb; background:rgba(10,12,14,.35);
    border:1px solid rgba(255,255,255,.06); backdrop-filter: blur(4px);
    padding:8px 10px; border-radius:8px;
  }
  .hud label{display:grid; gap:4px; align-items:center}
  .hud input[type="range"]{width:120px}
  .hud .row{display:flex; gap:12px; align-items:center}
  .btn{
    background:#11161a; color:#dfe5e7; border:1px solid #222b2f; padding:6px 9px; border-radius:6px; cursor:pointer;
  }
  .btn:hover{border-color:#2d3a40}
  .lamp{
    display:inline-flex; align-items:center; gap:6px; padding:4px 7px; border-radius:6px;
    border:1px solid #223037; background:#0d1417; color:#b4ffef;
    box-shadow:0 0 18px rgba(50,224,196,.08), inset 0 0 10px rgba(50,224,196,.06);
  }
  .lamp .dot{width:6px;height:6px;border-radius:50%; background:#223b37; box-shadow:0 0 8px rgba(50,224,196,.2)}
  .lamp.on .dot{background:var(--accent); box-shadow:0 0 16px rgba(50,224,196,.75)}
  footer{display:flex;align-items:center;justify-content:space-between; gap:12px; font-size:12px;color:#96a0a3;opacity:.9}
  code.k{background:#0f1518;border:1px solid #1d262b; padding:2px 6px; border-radius:6px; color:#d9fdf7}
  .log{max-width:52ch; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Gnostic Sigil Pareidolia — Static</h1>
      <div id="myth">“The channel is always open; you’re just learning where to look.”</div>
    </header>

    <div class="pane scanline">
      <canvas id="snow"></canvas>

      <div class="hud" id="hud">
        <div class="row">
          <span class="lamp" id="scryLamp"><span class="dot"></span> Scry</span>
          <label>Density <input type="range" id="density" min="0" max="1" step="0.01" value="0.62"></label>
          <label>Contrast <input type="range" id="contrast" min="0.5" max="3" step="0.01" value="1.35"></label>
          <label>Flicker Hz <input type="range" id="flicker" min="0" max="30" step="0.1" value="7.5"></label>
          <label>Drift <input type="range" id="drift" min="0" max="1" step="0.01" value="0.35"></label>
          <label>Hints <input type="range" id="hint" min="0" max="1" step="0.01" value="0.18"></label>
          <button class="btn" id="seedBtn">Reroll Seed</button>
          <button class="btn" id="markBtn">I saw something</button>
        </div>
      </div>
    </div>

    <footer>
      <div>
        Keys: <code class="k">H</code> toggle hints, <code class="k">S</code> scry mode, <code class="k">Space</code> mark moment, <code class="k">R</code> reroll seed, <code class="k">G</code> glow word.
      </div>
      <div class="log" id="lastMark">No marks yet.</div>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('snow');
  const glog = document.getElementById('lastMark');
  const lamp = document.getElementById('scryLamp');
  const dSlider = document.getElementById('density');
  const cSlider = document.getElementById('contrast');
  const fSlider = document.getElementById('flicker');
  const driftSlider = document.getElementById('drift');
  const hintSlider = document.getElementById('hint');
  const seedBtn = document.getElementById('seedBtn');
  const markBtn = document.getElementById('markBtn');

  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:false });
  let W, H, scale = 1; // devicePixelRatio factor later
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function size() {
    const bb = canvas.parentElement.getBoundingClientRect();
    W = Math.floor(bb.width * DPR);
    H = Math.floor(bb.height * DPR);
    // keep texture reasonable for perf
    const target = 300_000; // pixels
    const area = W*H;
    const factor = Math.sqrt(area/target);
    scale = Math.max(1, Math.min(DPR, factor));
    canvas.width = Math.floor(W/scale);
    canvas.height = Math.floor(H/scale);
    canvas.style.imageRendering = canvas.width < 800 ? 'pixelated' : 'auto';
  }
  size();
  addEventListener('resize', size);

  // RNG with seed
  let seed = Math.random() * 1e9 >>> 0;
  function rng() {
    // xorshift32
    let x = seed |= 0;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    seed = x >>> 0;
    return (seed & 0xffffffff) / 0x100000000;
  }
  function reseed() {
    seed = (performance.now() * 1000 | 0) ^ (Math.random() * 1e9 | 0);
  }

  seedBtn.onclick = () => { reseed(); latentSigil = makeSigil(); };
  markBtn.onclick = markMoment;

  // Two noise fields that crossfade => “drift”
  let t = 0;
  const fieldA = new Uint8ClampedArray();
  const fieldB = new Uint8ClampedArray();
  let latentSigil = makeSigil();

  function makeSigil(){
    // Build a faint mask containing near-symmetric “eye/sigil-ish” blobs and strokes.
    const w = 256, h = 256;
    const off = new OffscreenCanvas(w, h);
    const octx = off.getContext('2d');
    octx.clearRect(0,0,w,h);
    octx.globalCompositeOperation = 'lighter';
    const blobs = 6 + (rng()*6|0);
    for(let i=0;i<blobs;i++){
      const cx = (rng()*0.6+0.2)*w;
      const cy = (rng()*0.6+0.2)*h;
      const r = (rng()*40+18);
      const a = 0.02 + rng()*0.035;
      radial(octx,cx,cy,r,a);
      // mirror to hint "faces"
      radial(octx,w-cx,cy,r*0.92,a*0.9);
    }
    // draw a few soft strokes (like ∆, ◉, ⟁ suggestions)
    octx.globalAlpha = 0.06;
    octx.lineWidth = 2;
    octx.strokeStyle = '#fff';
    for(let i=0;i<4;i++){
      octx.beginPath();
      octx.moveTo(rng()*w, rng()*h);
      octx.quadraticCurveTo(rng()*w, rng()*h, rng()*w, rng()*h);
      octx.stroke();
    }
    return off;
    function radial(c,x,y,r,alpha){
      const g = c.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0, `rgba(255,255,255,${alpha})`);
      g.addColorStop(1, `rgba(255,255,255,0)`);
      c.fillStyle = g; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
    }
  }

  function makeField(buf,w,h,density){
    // white noise with adjustable density and slight clumping using box blur passes
    for(let i=0;i<w*h;i++){
      const v = rng();
      buf[i] = v < density ? 255 : 0;
    }
    // blur once to create “snow clots”
    boxBlur(buf,w,h,1);
  }

  function boxBlur(buf,w,h,r){
    // very cheap separable blur on binarized field
    const tmp = new Uint8ClampedArray(buf.length);
    for(let y=0;y<h;y++){
      let acc=0;
      for(let x=0;x<w;x++){
        acc += buf[y*w+Math.max(0,x-r)] - (x-r-1>=0?buf[y*w+(x-r-1)]:0);
        tmp[y*w+x] = acc/(Math.min(x+1,r*2+1)*255)*255;
      }
    }
    for(let x=0;x<w;x++){
      let acc=0;
      for(let y=0;y<h;y++){
        const idx = y*w + x;
        acc += tmp[Math.max(0,y-r)*w+x] - (y-r-1>=0?tmp[(y-r-1)*w+x]:0);
        buf[idx] = acc/(Math.min(y+1,r*2+1)*255)*255;
      }
    }
  }

  function frame(ts){
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w,h);
    const data = img.data;

    // occasionally remake fields (flicker)
    const hz = parseFloat(fSlider.value); // frames per second magnitude
    const step = hz <= 0 ? 999 : Math.max(1, Math.floor(60/Math.max(1,hz)));
    if ((t % step) === 0) {
      makeField(fieldA, w, h, parseFloat(dSlider.value));
    }
    // second field drifts slowly
    if ((t % (step*2)) === 0) {
      makeField(fieldB, w, h, parseFloat(dSlider.value)*0.96 + 0.02);
    }

    const drift = parseFloat(driftSlider.value); // 0..1
    const contrast = parseFloat(cSlider.value);
    const hints = hintSlider.value;

    // mix fields + small temporal noise for shimmer
    for (let i=0,px=0;i<w*h;i++,px+=4){
      const a = fieldA[i]||0, b = fieldB[i]||0;
      let v = a*(1-drift) + b*drift;
      // add light shimmer
      v += (rng()*35 - 17);
      // contrast curve
      let n = Math.max(0, Math.min(255, ((v-128)*contrast)+128));
      data[px]=data[px+1]=data[px+2]=n;
      data[px+3]=255;
    }

    // latent sigil mask (very low alpha, scaled & drifted)
    if (hints > 0.001){
      const s = latentSigil;
      const lw = Math.floor(w*0.9), lh = Math.floor(h*0.9);
      const dx = Math.floor((w-lw)/2 + Math.sin(t*0.003)*w*0.02);
      const dy = Math.floor((h-lh)/2 + Math.cos(t*0.002)*h*0.02);
      ctx.putImageData(img,0,0);
      ctx.globalAlpha = hints*0.65;
      ctx.globalCompositeOperation = 'screen';
      ctx.drawImage(s, dx, dy, lw, lh);
      ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.putImageData(img,0,0);
    }

    t++;
    requestAnimationFrame(frame);
  }

  // initial fields sized to canvas
  const ensureFields = () => {
    const count = canvas.width * canvas.height;
    if (fieldA.length !== count) {
      fieldA.set?.length = 0;
    }
  };
  ensureFields();
  requestAnimationFrame(frame);

  // Scry mode: raises contrast, lowers flicker, slows drift, boosts hints slightly
  let scry = false;
  function toggleScry(state){
    scry = (state===undefined)? !scry : !!state;
    lamp.classList.toggle('on', scry);
    if (scry){
      cSlider.value = (+cSlider.value * 1.25).toFixed(2);
      fSlider.value = Math.max(0, (+fSlider.value * 0.45)).toFixed(2);
      driftSlider.value = Math.max(0.08, (+driftSlider.value * 0.6)).toFixed(2);
      hintSlider.value = Math.min(0.45, (+hintSlider.value + 0.06)).toFixed(2);
      document.getElementById('myth').textContent = '“Hold your breath on the exhale; the channel brightens.”';
    } else {
      document.getElementById('myth').textContent = '“The channel is always open; you’re just learning where to look.”';
    }
  }
  lamp.onclick = () => toggleScry();

  // Mark moments (mini ritual log)
  function markMoment(){
    const stamp = new Date().toLocaleTimeString();
    glog.textContent = `Marked at ${stamp} — “Noted an appearance.”`;
    glog.style.color = 'var(--fg)';
    setTimeout(()=>glog.style.color='#96a0a3', 1600);
    // light “glow word” easter egg
    if (Math.random() < 0.22) glowWord();
  }

  // Occasional teal word that fades (ties to your earlier aesthetic)
  function glowWord(){
    const words = ['SEEN','TRACE','LISTEN','VEIL','ARCHIVE','ECHO','FATE','GNOSIS'];
    const w = words[(Math.random()*words.length)|0];
    const el = document.createElement('div');
    Object.assign(el.style,{
      position:'absolute',left:'50%',top:'50%',transform:'translate(-50%,-50%)',
      color:'var(--fg)', fontWeight:'600', letterSpacing:'0.28em',
      textTransform:'uppercase', textShadow:'0 0 14px rgba(50,224,196,.75)',
      opacity:'0', filter:'blur(1px)', fontSize:'clamp(12px,2.6vw,24px)', pointerEvents:'none'
    });
    el.textContent = w;
    canvas.parentElement.appendChild(el);
    let a=0; const anim = () => {
      a += 0.03; el.style.opacity = String(Math.sin(a)*0.9);
      if (a<Math.PI) requestAnimationFrame(anim); else el.remove();
    }; anim();
  }

  // Keyboard
  addEventListener('keydown', (e)=>{
    if (e.code==='Space'){ e.preventDefault(); markMoment(); }
    else if (e.key==='h' || e.key==='H'){ hintSlider.value = (hintSlider.value>0?0:0.18); }
    else if (e.key==='s' || e.key==='S'){ toggleScry(); }
    else if (e.key==='r' || e.key==='R'){ reseed(); latentSigil = makeSigil(); }
    else if (e.key==='g' || e.key==='G'){ glowWord(); }
  });

  // Ensure canvas fills nicely
  const fit = () => {
    // keep aspect flexible; nothing else needed because canvas is 100%/100%
  };
  addEventListener('resize', fit);

})();
</script>
</body>
</html>
